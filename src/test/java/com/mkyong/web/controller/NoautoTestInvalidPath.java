package com.mkyong.web.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import org.junit.Before;
import org.junit.experimental.theories.DataPoints;
import org.junit.experimental.theories.Theories;
import org.junit.experimental.theories.Theory;
import org.junit.runner.RunWith;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.mock.web.MockServletContext;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.resource.ResourceHttpRequestHandler;
import tech.anima.tinytypes.StringTinyType;

@RunWith(Theories.class)
public class TestInvalidPath {

    private ResourceHttpRequestHandler handler;

    @Before
    public void setUp() {
        List<Resource> resourcePaths = new ArrayList<>();
        resourcePaths.add(new ClassPathResource("test/", getClass()));
        resourcePaths.add(new ClassPathResource("testalternatepath/", getClass()));
        handler = new ResourceHttpRequestHandler();
        handler.setLocations(resourcePaths);
        handler.setCacheSeconds(3600);
        handler.setServletContext(new TestServletContext());
    }

    @DataPoints
    public static Th1[] urls = Stream.of(new String[]{
        "../testsecret/secret.txt",
        "test/../../testsecret/secret.txt",
        ":/../../testsecret/secret.txt"
    }).map(Th1::new).collect(Collectors.toList()).toArray(new Th1[]{});

    @Theory
    public void invalidPath1(Th1 path) throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setMethod("GET");
        MockHttpServletResponse response = new MockHttpServletResponse();

        Resource location = new ClassPathResource("test/", getClass());
        this.handler.setLocations(Arrays.asList(location));

        testInvalidPath(location, path.value, request, response);
    }
    @DataPoints
    public static Th2[] urls2 = Stream.of(new String[]{
        "file:" ,
        "/file:",
        "url:",
        "/url:",
        "/",
        "////../.." ,
        " " ,
        "/  ",
        "url:"
    }).map(Th2::new).collect(Collectors.toList()).toArray(new Th2[]{});

    @Theory
    public void invalidPath2(Th2 url) throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setMethod("GET");
        MockHttpServletResponse response = new MockHttpServletResponse();

        Resource location = new UrlResource(getClass().getResource("./test/"));
        this.handler.setLocations(Arrays.asList(location));
        Resource secretResource = new UrlResource(getClass().getResource("testsecret/secret.txt"));
        String secretPath = secretResource.getURL().getPath();
        
        testInvalidPath(location, url.value + secretPath, request, response);

    }
    @DataPoints
    public static Th3[] urls3 = Stream.of(new String[]{
        "/%2E%2E/testsecret/secret.txt",
        "/%2e%2e/testsecret/secret.txt"
    }).map(Th3::new).collect(Collectors.toList()).toArray(new Th3[]{});

    @Theory
    public void invalidPath3(Th3 url) throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setMethod("GET");
        MockHttpServletResponse response = new MockHttpServletResponse();

        Resource location = new UrlResource(getClass().getResource("./test/"));
        this.handler.setLocations(Arrays.asList(location));
        Resource secretResource = new UrlResource(getClass().getResource("testsecret/secret.txt"));
        String secretPath = secretResource.getURL().getPath();
        
        testInvalidPath(location, url.value, request, response);

    }

    private void testInvalidPath(Resource location, String requestPath,
            MockHttpServletRequest request, MockHttpServletResponse response) throws Exception {

        request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, requestPath);
        response = new MockHttpServletResponse();
        this.handler.handleRequest(request, response);
        assertTrue(location.createRelative(requestPath).exists());
        assertEquals(404, response.getStatus());
    }

    private static class TestServletContext extends MockServletContext {

        @Override
        public String getMimeType(String filePath) {
            if (filePath.endsWith(".css")) {
                return "text/css";
            } else if (filePath.endsWith(".js")) {
                return "text/javascript";
            } else {
                return super.getMimeType(filePath);
            }
        }
    }

    public static class Th1 extends StringTinyType {

        public Th1(String value) {
            super(value);
        }
    }

    public static class Th2 extends StringTinyType {

        public Th2(String value) {
            super(value);
        }
    }
    public static class Th3 extends StringTinyType {

        public Th3(String value) {
            super(value);
        }
    }
}
